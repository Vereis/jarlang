\documentclass[twoside,12pt,titlepage,a4paper]{article}
\usepackage{url}
% kentHarvard requires natbib
\usepackage{natbib}
% add line numbers
\usepackage{lineno}
%\linenumbers %Comment this out to remove line numbers

\usepackage[pass]{geometry}
\usepackage{graphicx}
\renewcommand{\baselinestretch}{1.3}
\usepackage{todonotes}
%\usepackage{minted}
\usepackage{subcaption}

% Fix weird page margins?
\setlength{\oddsidemargin}{1cm}
\setlength{\evensidemargin}{1cm}
\setcounter{secnumdepth}{3}

\title{CO600 Project: Jarlang\\ Technical Report}
\author{
	\begin{tabular}{ c c c }
		Chris Bailey & Andrew Johnson & Nick Laine \\
		\url{cb661@kent.ac.uk} & \url{apj8@kent.ac.uk} & \url{nl227@kent.ac.uk}
	\end{tabular}\\
	\\ \vspace{10mm}
	 \includegraphics[scale=0.6]{Kent_Comp_294_RGB} \\
	 School of Computing \\
	 University of Kent \\
	 United Kingdom \\ \vspace{10mm} \\ Word Count: 6,100}
\begin{document}

\newgeometry{hmarginratio=1:1}    %% make layout symmetric
\maketitle
\restoregeometry              %% restore the layout

\begin{abstract}
This paper describes the development and operation of an Erlang to JavaScript compiler henceforth referred to as \textit{Jarlang}.

The primary goal of Jarlang was originally to explore the feasibility of compiling Erlang source code into JavaScript such that people would be able to simply run it and demonstrate it on the open web. This is not only a convinient feature but also has applications for the educational use of Erlang, as well as simply improving existing documentation for Erlang with the use of real-time examples.

Being able to help create a unified stack for web development has also been a goal of the project, as such a concept is rather attractive to contemporary web developers.

Unlike similar projects such as \textit{LuvvieScript}, we aimed not to support a \textit{"subset of Erlang"} or create a new language \textit{"based on Erlang"}, but instead wanted to focus on implementing as much of Erlang, and its standard library, runtime and behaviours as possible on the web.
\end{abstract}

\section{Introduction}
\label{Introduction}
\textit{Jarlang} is a compiler implemented in Erlang and JavaScript, whose goal is to be able to compile valid Erlang module source code into valid JavaScript source code.

Jarlang thus provides several benefits to potential users such as the ability to execute, or demonstrate, Erlang code on the web which could help the official Erlang documentation but also provides educational benefits. Jarlang also allows developers to unify their tech-stack which is a popular trend amongst contemporary web developers. Unifying tech-stacks results in less time spent context switching when switching from front-end programming and back-end programming, as well as making both front-end and back-end programming accessible to any competant Erlang developer.

Most of our codebase is written in Erlang, which is the same language as our compilation source. The main motivation behind this is to eventually bootstrap the Jarlang compiler (compiling the compiler). If we were to compile Jarlang's source code into JavaScript, we essentially have an Erlang compiler which can run on its own on the web, only furthering educational benefit as Erlang programmers therefore don't need to install an Erlang compiler themselves. This would also allow Erlang to act moreso as a first class citizen on the Web.

Due to time constraints however, the currently implementation of the Jarlang compiler hooks into the existing Erlang compiler and thus has a hard dependency on it. We utilise the Erlang compiler to parse, lex, validate, and optimise Erlang source code. After these steps, the Erlang compiler allows us to manipulate its intermediate language known as \textit{Core Erlang}, which is where the Jarlang compiler performs most of its work.

In order to remove our dependency on the Erlang compiler, we will need to write a parser, lexer and validater for Erlang, as well as generate a Core Erlang compatible abstract syntax tree for us to work on, which whilst is not impossible, is definitely beyond the scope and time constraints of this project.

We also intended to, and in many ways, have succeeded in implementing much of Erlang's functionality --- The results of the Jarlang compiler successfully emulate Erlang style modules (including private and exported functions), Erlang style variadic functions and function overloading, and more abmitiously, implementing a concurrent actor-model system leveraging JavaScript's event loop.

\section{Background}
\label{Background}

\section{Aims}
\label{Aims}
The primary aim of \textit{Jarlang} is to generate valid JavaScript from any error-free Erlang module source code. The result of this JavaScript generation should be easily included on a given web-page and be easily integrated into existing front-end codebase.

Secondary aims for \textit{Jarlang} include the ability to leverage Erlang-style concurrency in what is more often than not a strictly single-threaded environment, as well as being able to \textit{execute correctly} the generated JavaScript --- this presumes the re-implementation of the Erlang standard library and Erlang runtime environment as the equivalent \textit{Jarlang runtime environment}.

While fully implementing the \textit{Jarlang runtime environment} is not the primary goal of this project, enough of the \textit{Jarlang runtime environment} will have been implemented so that we can successfully emulate things such as Erlang's datatypes, message passing and concurrency model --- otherwise, enough that basic test-compilations can be successfully run \textit{(common tests such as a simple 'Hello, World!', 'Fibbonaci' and 'Factorial')}.

\section{Project Results}
\label{Results}
As a high level summary, the Jarlang compiler is capable of successfully compiling Erlang source code into JavaScript source code. We make no promises as to whether or not the generated code will function correctly when speaking only about the Jarlang compiler, but much code that does not utilise standard library functions and instead operates mainly on Erlang primitives works as intended.

Example Erlang modules such as \textit{Fibbonaci}, \textit{Factorial} and simple multi-process communication tests such as a basic \textit{Ping-Pong server} seem to work without issue, and more complex Erlang modules such as Erlang OTP's \textit{List module} compile fine too. The main thing holding us back from getting functional compiled Erlang code is lack of a successfully implemented standard library and runtime.

The Jarlang runtime environment, as explained briefly above, is a large hand-written implementation (or re-implementation) of much of the Erlang standard library and Erlang runtime environment in JavaScript. Since all code generated by the Jarlang compiler assumes that the Jarlang runtime environment is working and fully implemented, many things which would trivially be made to work currently do not. This is because of the sheer scope of features found in the Erlang runtime and standard library and whilst progress has been made (much of the core \textit{Erlang module} and \textit{IO module} has been implemented, for instance), much core functionality is still missing.

Notable features of the Jarlang runtime environment in its current state, however, are listed below:

\begin{itemize}
\item Erlang Datatypes - The Jarlang runtime environment successfully reimplements and emulates all of the Erlang datatypes we have deemed to be implementable on the web, and are as follows: \textit{'Atoms', 'BitStrings', 'Floats (BigNum)', 'Integers (BigNum)', 'Lists', 'Maps', 'PIDs', 'Tuples','Unbounds', and 'Processes'}. We will go into more detail about these below.
\item Erlang's Concurrency Model - The compiled output of the Jarlang compiler intelligently wraps function calls into unique processes when needed. Each process has a mailbox and the ability to defer execution while awaiting messages to process and respond to. Processes can send messages to other processes and therefore trigger asynchronous behaviour via this mechanism. Furthermore, Processes live in a pool of active processes and are run asynchronously in JavaScript's event loop which seems to, at a high level, simulate the concurrency model used by Erlang.
\item IO and Erlang module - The Erlang IO module allows processes to print to the JavaScript console with a \textit{printf} style syntax. It closely emulates the same interface as the Erlang standard IO module and at a basic level is interoperable. The Erlang module is also implemented to the point where we can spawn processes, register processes in a global \textit{Atom table}, perform type casting and more.
\end{itemize}

A more detailed discussion of the segments which make up the Jarlang compiler and the Jarlang runtime system is discussed below.

\subsection{Jarlang Runtime Environment}
The Jarlang runtime environment is implemented as many seperate JavaScript modules which are processed and bound together by our NodeJS toolchain and tools such as \textit{Gulp}. The runtime is split into three distinct segments.

\begin{itemize}
\item Erlang Datatypes - Each Erlang datatype implemented as an ES6-spec JavaScript class in its own closure to keep track of private and public methods/properties.
\item Standard Library Modules - Each standard library module is implemented as an ES5-spec JavaScript module which interally also uses a closure in order to keep track of exported/unexported functions.
\item Runtime Specific Code - This exists enclosed within a single ES5-spec JavaScript module which creates the appropriate environment expected of an Erlang-like environment such as setting up a process pool, global atom table and more.
\end{itemize}

Whilst the implementation of the standard library modules and the runtime module is interesting as it follows the same pattern we use for implementing Erlang-style modules in JavaScript, details about this will be explore in section \ref{sssec:num1} as it is more relevant there. Otherwise, the composition of the runtime environment isn't particularly interested --- the components however, are.

\subsubsection{Erlang Datatypes}
Early builds of Jarlang attempted to simply make due with JavaScript's native datatypes as an attempt to generate more idomatic JavaScript. This was quickly scrapped when we hit some slightly more nuanced edge cases in Erlang such as type comparisons.

Values of any given type in Erlang can be compared against one another with the standard arithmatic comparison operators '$>$', '$<$', '$>=$', '$=<$'. Other operators such as '$=$' could also be seen as doing a type-to-type comparison also. Due to this, instead of implementing multiple typechecking checks in each of the function calls for the given arithmatic comparison operators, we opted instead to build custom classes which would let us easily implement such behaviour.

In order to easily and painlessly implement this behaviour, all datatype classes inherit from a custom type we defined called \textit{erlangDatatype} and therefore have several properties initialised by default such as \textit{erlangDatatype.value}, \textit{erlangDatatype.precedence} and auxillary functions intended to be overwritten such as \textit{erlangDatatype.toString()}, and \textit{erlangDatatype.match(N)}.

Following this, each datatype overwrites \textit{erlangDatatype.precedence} in its own class with a number which determines how it gets compared to values of a different type. Atoms in Erlang are less than everything for example, and thus in the Jarlang runtime environment, Atoms have a precedence value of 1 whilst everything else has a precedence value greater than 1.

In more complex cases, precedence is not the only value tested to determine the comparison of two values. Data collections such as Lists, BitStrings and Maps all override their \textit{erlangDatatype.match(N)} functionality so that they can correctly implement comparison matching as well as object equality checking which is then used for pattern matching.

Of course, each datatype then goes on to implement type-specific behaviour in an attempt to mimic type behaviour in Erlang. A high level outline of what each datatype does is given below:

\begin{itemize}
\item Atoms - Atoms are essentially just constant immutable values which are also singletons. When atoms are created, they register themselves in the runtime system's global atom table which keeps track of every atom which has ever been initialized. The global atom table is also a place where you can store references to processes, and as such atoms in the Jarlang runtime system (just like in Erlang), double as 'global identifiers' to processes.

\item BitStrings - BitStrings are contiguous arrangements of binary data in the Erlang world. We were originally not going to implement the BitString class because it doesn't really feel applicable on the web since you're never really dealing with any binary data, however, strings in Erlang are often represented as Binary strings and as such we needed to implement these to support such a common usecase. BitStrings use JavaScript's \textit{uint8Array} internally.

\item Floats/Ints - Numbers in Erlang have arbitrary precision and are implemented via the inclusion of the \textit{bignumber.js} library. This is the only part of Jarlang runtime which has an external dependency though we do package \textit{bignumber.js} in our runtime to be as simple as possible to use. Whilst the classes Float and Int aren't entirely identical, they share most of their interface. These classes implement typical mathematical functions such as addition, subtraction and multiplication which is what gets used by the Jarlang runtime system whenever it performs mathematical calculations.

\item Lists - Lists are implemented as a recursive datatype such that a List can contain a value and a reference to another List. This allows efficient implementation of the \textit{cons operator}, and is also simply how its done in Erlang too. Proper lists always end in an empty list, but since Erlang allows improper lists, \textit{consing} a list with any non-list item will return an \textit{improper list}. Normal strings are also represented as lists in Erlang and as such, Lists are able to reflect upon their contents and render themselves as JavaScript strings if their makeup is entirely of integers which lie within a certain range of values Erlang denotes as printable ASCII characters.

\item Maps - Maps in the Jarlang runtime environment were originally implemented as wrappers over JavaScript Objects. This was changed when we realised the matching behaviour of Maps performs comparisons on the underlying keys stored within said Map. As such, Maps are currently implemented using two JavaScript arrays --- one for keys (which can be non-serialized objects of any kind), and the other for values such that looking up the \textit{i\textsuperscript{th}} value of the keys array returns the \textit{i\textsuperscript{th}} value of the values array.

\item PID - PIDs are process identifiers and are usually only created when new processes are spawned. PIDs act simply as an identifier and thus they don't have any special functionality outside of being keys to processes in the runtime system's global process table. PIDs are made up of three identifying features: the node where the PID exists (allowing for distributed processing), and two other IDs. Distribution of PIDs isn't implemented or handled by the runtime environment however and thus are left to Jarlang's users to implement themselves --- PIDs do however, because of this, expose an API allowing you to programmatically control what precise PID gets spawned at a given time.

\item Processes - At a high level, these are agents which execute a given behaviour (encapsulating a function call) asynchronously. These are explained in depth in section \ref{sssec:num2}.

\item Tuples - Tuples behave like lists of fixed size. They don't have the ability to \textit{cons} with other tuples but are implemented in a similar way to lists for easier pattern-matching implementation.

\end{itemize}

Because each datatype inherits properties such as \textit{erlangDatatype.value}, these datatypes are often interacted with by querying the value stored in \textit{erlangDatatype.value}. The only gap in our datatype abstraction is the lack of a \textit{fun} datatype as we are compiling Erlang functions into JavaScript functions. 

Any time a user makes a call to compiled Erlang code, they are in fact invoking the Jarlang runtime system. All Erlang related code is processed purely using these datatypes and as such there is an issue of JavaScript-Jarlang Interoperability which we describe and resolve (somewhat) below.

\subsubsection{JavaScript - Jarlang Interoperability}
There was originally quite an annoying issue of lack of interoperability between the 'outside JavaScript world' and our 'internal Jarlang world'. 

Given an Erlang function which is called with the following: \textit{fibbonaci:fibb(12)}, originally, a user of Jarlang would have had to execute \textit{fibbonaci.fib(new Int(12))} in order to get it to work as they expected. This issue affected us as well while testing; more complex datatypes such as, in Erlang: \textit{[1, 2, {3, 3}]}, would have had to been written, in JavaScript, as \textit{new List(new Int(1), new Int(2), new Tuple(new Int(3), new Int(3)))} which not only was much more verbose, but was simply not friendly to use.

We got around this by implementing functions which try their best to convert JavaScript types into their natural Erlang types where applicable. These functions are automatically wrapped around any potential user input such as around exported functions of any modules, as well as any potential output. This means that for all simple cases, the user can run \textit{fibbonaci.fib(12)} and expect it to work just like the Erlang equivalent. These functions are also exposed in our public API so that users can manually call these type conversions should they need to in their own native JavaScript code.

When converting JavaScript types to Erlang types, there the following types are mapped to eachother:

\begin{itemize}
\item Number $\Rightarrow$ Int/Float (depending on value of given Number)
\item String $\Rightarrow$ List
\item Array $\Rightarrow$ List
\item Uint8Array $\Rightarrow$ BitString
\item Object $\Rightarrow$ Map
\end{itemize}

Any non-mapped datatypes will need to be manually created as before though, so functions which require an Atom will need to call said code with \textit{new Atom(\dots)}.

When converting Erlang types into JavaScript, the converted types are more expressive as they can generate themselves as tagged JavaScript objects. They are mapped as follows:

\begin{itemize}
\item Atom $\Rightarrow$ String
\item BitString $\Rightarrow$ Uint8Array
\item List $\Rightarrow$ String or Array, depending the values within the List
\item Map $\Rightarrow$ An Object in the form of \textit{\{ keys: [...], values: [...] \}}
\item Int/Float $\Rightarrow$ Number
\item Pid $\Rightarrow$ Not converted. Exposed as raw Erlang datatype.
\item Process $\Rightarrow$ Not converted. Exposed as raw Erlang datatype.
\item Tuple $\Rightarrow$ Array
\end{itemize}

The main downside to this automatic type conversion system is when dealing with anonymous functions on both the JavaScript side and the Erlang side. Since we're using JavaScript functions as the datatype representing Erlang functions, we can pass them around and invoke them as normal first class objects but the issue is that it is impossible for the arguments going into these functions and coming out of these functions to be automatically converted. This is an area of active research though I don't believe we'll find an adequate solution in the near future.

Lastly, since Erlang function calls in the form \textit{module:function(\dots)} are simply compiled to \textit{module.function(\dots)}, Erlang code can call native browser APIs, as well as user defined functions by simply making a call to that code. Calling \textit{window:function(\dots)} allows access to any globally accessible functions, though for ease of use, the Jarlang runtime will eventually include its own wrapper around much of the standard JavaScript APIs allowing even better interoperability.

\subsubsection{Sequential Programming (or lack thereof)}
\subsubsection{Concurrent Programming} \label{sssec:num2}
\subsubsection{Distributed Programming}

\subsection{AST Conversion}
By using the Erlang compiler to produce Core Erlang and it's AST representation we have secured several benefits, some minor conveniences and some critical to achieving a viable program in the time available to us.
\subsubsection{Compiler Generated Code}
In Erlang conditional logic \& function pattern matching, unless explicitly defined in the source code, an error is thrown when the supplied value or parameters do not match any of the required patterns. fortunately we have not been required to create this functionality directly, rather, during compilation to Core Erlang the Erlang compiler adds a catch-all clause to the associated code that will explicitly call the built-in-function that emits errors.

For example the Erlang function shown in Figure \ref{fig:code_comparison:erl} will throw an error if the input is anything other than the atom 'apple'. In this example there is no code that states what should occur in the event that the input is not the atom 'apple' and as such the compiler generates a second clause (Figure \ref{fig:code_comparison:erl_ast}) to match any value and throw an appropriate error. This conveniently allows us to reproduce the required functionality by parsing the compiler generated function as normal (Figure \ref{fig:code_comparison:js}), rather than concerning ourselves with this specific case.
	%\begin{figure}[htb]
		%\centering
		% \begin{figure}[t]
		% 	\centering
		% 		\begin{verbatim}
		% 		...
		% 		error_if_not_apple(apple)->
		% 		  ok.
		% 		\end{verbatim}
		% 	\caption{Erlang source}
		% 	\label{fig:code_comparison:erl}
		% \end{figure}
		% \begin{figure}[t]
		% 	\centering
		% 	\begin{verbatim}
		% 	...
		% 	[{{c_var,[],{error_if_not_apple,1}},
		% 	  {c_fun,[],
		% 	    [{c_var,[],'_cor0'}],
		% 	    {c_case,[],
		% 	      {c_var,[],'_cor0'},
		% 	      [{c_clause,[],
		% 	         [{c_literal,[],apple}],
		% 	         {c_literal,[],true},
		% 	         {c_literal,[],ok}},
		% 	       {c_clause,
		% 	         [compiler_generated],
		% 	         [{c_var,[],'_cor1'}],
		% 	         {c_literal,[],true},
		% 	         {c_primop,
		% 	           [{function_name,{error_if_not_apple,1}}],
		% 	           {c_literal,[],match_fail},
		% 	           [{c_tuple,[],
		% 	             [{c_literal,[],function_clause},
		% 	                {c_var,[],'_cor1'}]}]}}]}}},
		% 	...
		% 	\end{verbatim}
		% 	\caption{Core Erlang AST of Figure \ref{fig:code_comparison:erl}}
		% 	\label{fig:code_comparison:erl_ast}
		% \end{figure}
		% \begin{figure}[t]
		% 	\centering
		% 		\begin{verbatim}
		% 		...
		% 		'error_if_not_apple/1': function (_cor0) {
		% 		  if (function () {
		% 		    if (_cor0.match(new Atom('apple'))) {
		% 		      return new Atom('true');
		% 		    }
		% 		  }.bind(this)()) {
		% 		    return new Atom('ok');
		% 		  } else if (function () {
		% 		    return new Atom('true');
		% 		  }()) {
		% 		    let _cor1 = _cor0;
		% 		    throw '** match_fail: TODO Errors dont parse nicely\\n' + 'Message';
		% 		  }
		% 		},
		% 		...
		% 		\end{verbatim}
		% 	\caption{Jarlang transpiled equivalent of Figure \ref{fig:code_comparison:erl}}
		% 	\label{fig:code_comparison:js}
		% \end{figure}
		%\caption{Very code. Much geek. Wow!}
		%\caption{Comparison of Erlang source code and Jarlang transpiled equivalent.}
		%\label{fig:code_comparison}
	%\end{figure}


\subsubsection{Pattern Matching, Conditional Logic \& Message Receiving}
\subsubsection{Variable Declaration \& Assignment in Matching}
\subsubsection{Erlang Module implementation} \label{sssec:num1}
\subsection{ErlPKG}

\section{Conclusions}
\label{Conclusions}

[section not done yet]

\section{Acknowledgement}
The authors wish to thank and/or acknowledge the following:
\begin{enumerate}
\item Scott Owens - For supervising our project, and being generally available whenever we needed help or assistance, and talked us through just about all of our technical decisions.
\item Simon Thompson - For convincing us that rolling our own type checking system was not a good idea (and introducing to us the amazing \textit{Erlang Dialyzer}), and talking with us about the feasibility in our concurrency approach.
\item Gordon Guthrie - For his similar project --- \textit{LuvvieScript (URL now defunct)} --- and though no useful source-code was shared, his talk about how he tackled hooking into the Erlang compiler and tools he used (\textit{such as ESPrima and ESCodegen}) provided a brilliant starting point for \textit{Jarlang}.
\end{enumerate}
\appendix
\section*{Appendix A. TODO: Do we need an appendix?}


[section ommitted]



\vskip 0.2in
\todo{Bibliography is still the template version, will need replacing.}
\bibliography{jarlang_technical_report}
\bibliographystyle{kentHarvard}

\end{document}
