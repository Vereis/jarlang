\documentclass[twoside,12pt,titlepage,a4paper]{article}
\usepackage{url}
% kentHarvard requires natbib
\usepackage{natbib}
% add line numbers
\usepackage{lineno}
%\linenumbers %Comment this out to remove line numbers

\usepackage[pass]{geometry}
\usepackage{graphicx}
\renewcommand{\baselinestretch}{1.3}
\usepackage{todonotes}
%\usepackage{minted}
\usepackage{subcaption}

% Fix weird page margins?
\setlength{\oddsidemargin}{1cm}
\setlength{\evensidemargin}{1cm}
\setcounter{secnumdepth}{3}
\raggedbottom

\title{CO600 Project: Jarlang\\ Technical Report}
\author{
	\begin{tabular}{ c c c }
		Chris Bailey & Andrew Johnson & Nick Laine \\
		\url{cb661@kent.ac.uk} & \url{apj8@kent.ac.uk} & \url{nl227@kent.ac.uk}
	\end{tabular}\\
	\\ \vspace{10mm}
		\includegraphics[scale=0.6]{Kent_Comp_294_RGB} \\
		School of Computing \\
		University of Kent \\
		United Kingdom \\ \vspace{10mm} \\ Word Count: 6,100}
\begin{document}

\newgeometry{hmarginratio=1:1}    %% make layout symmetric
\maketitle
\restoregeometry              %% restore the layout

\begin{abstract}
	This paper describes the development and operation of an Erlang to JavaScript compiler henceforth referred to as \textit{Jarlang}.
	
	The primary goal of Jarlang was originally to explore the feasibility of compiling Erlang source code into JavaScript such that people would be able to simply run it and demonstrate it on the open web. This is not only a convinient feature but also has applications for the educational use of Erlang, as well as simply improving existing documentation for Erlang with the use of real-time examples.
	
	Being able to help create a unified stack for web development has also been a goal of the project, as such a concept is rather attractive to contemporary web developers.
	
	Unlike similar projects such as \textit{LuvvieScript}, we aimed not to support a \textit{"subset of Erlang"} or create a new language \textit{"based on Erlang"}, but instead wanted to focus on implementing as much of Erlang, and its standard library, runtime and behaviours as possible on the web.
\end{abstract}

\section{Introduction}
\label{Introduction}
\textit{Jarlang} is a compiler implemented in Erlang and JavaScript, whose goal is to compile valid Erlang module source code into valid JavaScript source code.

Jarlang thus provides several benefits to potential users such as the ability to execute, or demonstrate, Erlang code on the web which could help the official Erlang documentation but also provides educational benefits. Jarlang also allows developers to unify their tech-stack which is a popular trend amongst contemporary web developers. Unifying tech-stacks results in less time spent context switching when switching from front-end programming and back-end programming, as well as making both front-end and back-end programming accessible to any competant Erlang developer.

Most of our code is written in Erlang, which is the same language as our compilation source. The main motivation behind this is to eventually bootstrap the Jarlang compiler (compiling the compiler). If we were to compile Jarlang's source code into JavaScript, we essentially have an Erlang compiler which can run on its own on the web, only furthering educational benefit as Erlang programmers therefore don't need to install an Erlang compiler themselves. This would also allow Erlang to act moreso as a first class citizen on the Web.

Due to time constraints however, the currently implementation of the Jarlang compiler hooks into the existing Erlang compiler and thus has a hard dependency on it. We utilise the Erlang compiler to parse, lex, validate, and optimise Erlang source code. After these steps, the Erlang compiler allows us to manipulate its intermediate language known as \textit{Core Erlang}, which is where the Jarlang compiler performs most of its work.

In order to remove our dependency on the Erlang compiler, we will need to write a parser, lexer and validater for Erlang, as well as generate a Core Erlang compatible abstract syntax tree for us to work on, which whilst is not impossible, is definitely beyond the scope and time constraints of this project.

In order to remove our dependency on the Erlang compiler, we would need to essentially reimplement it (write a parser \& lexer for example, as well as AST generation) or leverage Jarlang to compile the Erlang compiler itself into JavaScript. This requires Jarlang to be more fully implemented than it currently is but in the long term, its definitely not an impossible goal.

We also intended to, and in many ways, have succeeded in implementing much of Erlang's functionality --- The results of the Jarlang compiler successfully emulate Erlang style modules (including private and exported functions), Erlang style variadic functions and function overloading, and more abmitiously, implementing a concurrent actor-model system leveraging JavaScript's event loop.

At the time of writing, Jarlang can successfully compile and run not just simple test programs such as Factorial or Fibonnaci, but also concurrent-reliant programs such as a Heartbeat protocol client/server, OTP style server/state-machine/event-handlers and interop with JavaScript to the extent where we've succesfully leveraged Jarlang compiled Erlang code to write simple games and instant messaging applications.

\section{Background}
\label{Background}

\section{Aims}
\label{Aims}
The primary aim of \textit{Jarlang} is to generate valid JavaScript from any error-free Erlang module source code which can then be integreated into any front-end codebase.

Secondary aims for \textit{Jarlang} include the ability to leverage Erlang-style concurrency in what is more often than not a strictly single-threaded environment, as well as being able to \textit{execute correctly} the generated JavaScript --- this presumes the re-implementation of the Erlang standard library and Erlang runtime environment as the equivalent \textit{Jarlang runtime environment}.

While fully implementing the \textit{Jarlang runtime environment} is not the primary goal of this project, enough of the \textit{Jarlang runtime environment} has been implemented so that we can successfully emulate things such as Erlang's datatypes, message passing and concurrency model --- allowing us to run tests and write example applications as already introduced.

\section{Project Results}
\label{Results}
Whilst we lack a fully implemented Jarlang runtime environment, at the time of writing the runtime environment and Jarlang compiler is complete enough to run simple Erlang programs on the web as well as successfully and quite easily integrate into existing JavaScript codebases allowing JavaScript code to leverage the power that Erlang's simple actor-style concurrency brings to the table.

We have many test examples working ranging from simple 'Hello world!' type applications, to datatype benchmarking and Erlang-compatability testing. In terms of more sizable applications, we were able to compile Erlang assignments from our second year of study also. Interoperability is at a point where it is trivial for JavaScript to interact with compiled Erlang code and Erlang code can trivially call into JavaScript code.

The Jarlang runtime environment, as explained briefly above, is a large hand-written re-implementation of much of the Erlang standard library and Erlang runtime environment in JavaScript (currently sitting at around 5500 lines of code). 

Since all code generated by the Jarlang compiler assumes that the Jarlang runtime environment is working and fully implemented, many things which could trivially be made to work currently may not. This is because of the sheer scope of features found in the Erlang runtime and standard library and whilst progress has been made (much of the core \textit{Erlang module} and \textit{IO module} has been implemented, for instance), much core functionality is still missing.

We intend to eventually utilising the Jarlang compiler to compile most of the standard Erlang library for us however, much of it is implemented in C which unfortunately does need to be rewritten from scratch. 

Notable features of the Jarlang runtime environment in its current state are listed below:

\begin{itemize}
	\item Erlang Datatypes - The Jarlang runtime environment successfully reimplements and emulates all of the Erlang datatypes we have deemed to be implementable on the web, and are as follows: \textit{'Atoms', 'BitStrings', 'Floats (BigNum)', 'Integers (BigNum)', 'Lists', 'Maps', 'PIDs', 'Tuples','Unbounds', and 'Processes'}. We will go into more detail about these below.
	\item Erlang's Concurrency Model - The compiled output of the Jarlang compiler intelligently wraps function calls into unique processes when needed. Each process has a mailbox and the ability to defer execution while awaiting messages to process and respond to. Processes can send messages to other processes and therefore trigger asynchronous behaviour via this mechanism. Furthermore, Processes live in a pool of active processes and are run asynchronously in JavaScript's event loop which seems to, at a high level, simulate the concurrency model used by Erlang.
	\item IO and Erlang module - The Erlang IO module allows processes to print to the JavaScript console with a \textit{printf} style syntax. It closely emulates the same interface as the Erlang standard IO module and at a basic level is interoperable. The Erlang module is also implemented to the point where we can spawn processes, register processes in a global \textit{Atom table}, perform type casting and more.
\end{itemize}

\subsection{The Jarlang Runtime Environment}
The Jarlang runtime environment is implemented as many seperate JavaScript modules which are processed and bound together by our NodeJS toolchain and tools such as \textit{Gulp}. The runtime is split into three distinct segments.

\begin{itemize}
	\item Erlang Datatypes - Each Erlang datatype implemented as an ES6-spec JavaScript class in its own closure to keep track of private and public methods/properties.
	\item Standard Library Modules - Each standard library module is implemented as an ES5-spec JavaScript module which interally also uses a closure in order to keep track of exported/unexported functions.
	\item Runtime Specific Code - This exists enclosed within a single ES5-spec JavaScript module which creates the appropriate environment expected of an Erlang-like environment such as setting up a process pool, global atom table and more.
\end{itemize}

Whilst the implementation of the standard library modules and the runtime module is interesting as it follows the same pattern we use for implementing Erlang-style modules in JavaScript, details about this will be explore in section \ref{sssec:num1} as it is more relevant there. Otherwise, the composition of the runtime environment isn't particularly interested --- the components however, are.

\subsubsection{Erlang Datatypes}
Early builds of Jarlang attempted to simply make due with JavaScript's native datatypes as an attempt to generate more idomatic JavaScript. This was quickly scrapped when we hit some slightly more nuanced edge cases in Erlang such as type comparisons.

Values of any given type in Erlang can be compared against one another with the standard arithmatic comparison operators '$>$', '$<$', '$>=$', '$=<$'. Other operators such as '$=$' could also be seen as doing a type-to-type comparison also. Due to this, instead of implementing multiple typechecking checks in each of the function calls for the given arithmatic comparison operators, we opted instead to build custom classes which would let us easily implement such behaviour.

In order to easily and painlessly implement this behaviour, all datatype classes inherit from a custom type we defined called \textit{erlangDatatype} and therefore have several properties initialised by default such as \textit{erlangDatatype.value}, \textit{erlangDatatype.precedence} and auxillary functions intended to be overwritten such as \textit{erlangDatatype.toString()}, and \textit{erlangDatatype.match(N)}.

Following this, each datatype overwrites \textit{erlangDatatype.precedence} in its own class with a number which determines how it gets compared to values of a different type. Atoms in Erlang are less than everything for example, and thus in the Jarlang runtime environment, Atoms have a precedence value of 1 whilst everything else has a precedence value greater than 1.

In more complex cases, precedence is not the only value tested to determine the comparison of two values. Data collections such as Lists, BitStrings and Maps all override their \textit{erlangDatatype.match(N)} functionality so that they can correctly implement comparison matching as well as object equality checking which is then used for pattern matching.

Of course, each datatype then goes on to implement type-specific behaviour in an attempt to mimic type behaviour in Erlang. A high level outline of what each datatype does is given below:

\begin{itemize}
	\item Atoms - Atoms are essentially just constant immutable values which are also singletons. When atoms are created, they register themselves in the runtime system's global atom table which keeps track of every atom which has ever been initialized. The global atom table is also a place where you can store references to processes, and as such atoms in the Jarlang runtime system (just like in Erlang), double as 'global identifiers' to processes.
			
	\item BitStrings - BitStrings are contiguous arrangements of binary data in the Erlang world. We were originally not going to implement the BitString class because it's not something you'd commonly work with on the web; however, strings in Erlang are often represented as Binary strings and as such we needed to implement these to support such a common usecase. BitStrings use JavaScript's \textit{uint8Array} internally. Bitstrings can be pattern matched against like Lists, Maps and Tuples but posess the unique property of being able to match byte patterns into variables allowing for simple implementation of binary format parsers.
			
	\item Floats/Ints - Numbers in Erlang have arbitrary precision and are implemented via the inclusion of the \textit{bignumber.js} library. This is the only part of Jarlang runtime which has an external dependency though we do package \textit{bignumber.js} in our runtime to be as simple as possible to use. Whilst the classes Float and Int aren't entirely identical, they share most of their interface. These classes implement typical mathematical functions such as addition, subtraction and multiplication which is what gets used by the Jarlang runtime system whenever it performs mathematical calculations.
			
	\item Lists - Lists are implemented as immutable linked lists to allow us to have an efficient implementation of the \textit{cons operator} which mimics Erlang's very own implementation. Each list contains a value and a \textit{next} value. A list is said have a length of one when it has a value and points to an empty list. Erlang allows lists to be \textit{improper} however, which means that lists can point to any other datastructure/primitive but doesn't promise that common list operations will work on these improper lists. Erlang stringss are also denoted as lists --- any list containing only integers within some printable ASCII range are considered and printed as strings by Jarlang as well as Erlang.
			
	\item Maps - Maps in the Jarlang runtime environment were originally implemented as wrappers over JavaScript Objects. This was changed when we realised the matching behaviour of Maps performs comparisons on the underlying keys stored within said Map. As such, Maps are currently implemented using two JavaScript arrays --- one for keys (which can be non-serialized objects of any kind), and the other for values such that looking up the \textit{i\textsuperscript{th}} value of the keys array returns the \textit{i\textsuperscript{th}} value of the values array. This was implemented like this because it was the easiest way for us to implement the size comparison functions for Maps internally, however we realise now in retrospect that we ought to refactor this into a more efficient tree data structure in the future should we revisit this datatype.
			
	\item PID - PIDs are process identifiers and are usually only created when new processes are spawned. PIDs act simply as an identifier and thus they don't have any special functionality outside of being keys to processes in the runtime system's global process table. PIDs are made up of three identifying features: the node where the PID exists (allowing for distributed processing), and two other IDs. Distribution of PIDs isn't implemented or handled by the runtime environment however and thus are left to Jarlang's users to implement themselves --- PIDs do however, because of this, expose an API allowing you to programmatically control what precise PID gets spawned at a given time.
			
	\item Processes - At a high level, these are agents which execute a given behaviour (encapsulating a function call) asynchronously. These are explained in depth in section \ref{sssec:num2}.
			
	\item Tuples - Tuples behave like lists of fixed size. They don't have the ability to \textit{cons} with other tuples but are implemented in a similar way to lists for easier pattern-matching implementation.
			
\end{itemize}

Because each datatype inherits properties such as \textit{erlangDatatype.value}, these datatypes are often interacted with by querying the value stored in \textit{erlangDatatype.value}. The only gap in our datatype abstraction is the lack of a \textit{fun} datatype as we are compiling Erlang functions into JavaScript functions. 

Any time a user makes a call to compiled Erlang code, they are in fact invoking the Jarlang runtime system. All Erlang related code is processed purely using these datatypes and as such there is an issue of JavaScript-Jarlang Interoperability which we describe and resolve (somewhat) below.

\subsubsection{JavaScript - Jarlang Interoperability}
There was originally quite an annoying issue of lack of interoperability between the 'outside JavaScript world' and our 'internal Jarlang world'. 

Given an Erlang function which is called with the following: \textit{fibbonaci:fibb(12)}, originally, a user of Jarlang would have had to execute \textit{fibbonaci.fib(new Int(12))} in order to get it to work as they expected. This issue affected us as well while testing; more complex datatypes such as, in Erlang: \textit{[1, 2, {3, 3}]}, would have had to been written, in JavaScript, as \textit{new List(new Int(1), new Int(2), new Tuple(new Int(3), new Int(3)))} which not only was much more verbose, but was simply not friendly to use.

We got around this by implementing functions which try their best to convert JavaScript types into their natural Erlang types where applicable. These functions are automatically wrapped around any potential user input such as around exported functions of any modules, as well as any potential output. This means that for all simple cases, the user can run \textit{fibbonaci.fib(12)} and expect it to work just like the Erlang equivalent. These functions are also exposed in our public API so that users can manually call these type conversions should they need to in their own native JavaScript code.

When converting JavaScript types to Erlang types, there the following types are mapped to eachother:

\begin{itemize}
	\item Number $\Rightarrow$ Int/Float (depending on value of given Number)
	\item String $\Rightarrow$ List
	\item Array $\Rightarrow$ List
	\item Uint8Array $\Rightarrow$ BitString
	\item Object $\Rightarrow$ Map
\end{itemize}

Any non-mapped datatypes will need to be manually created as before though, so functions which require an Atom will need to call said code with \textit{new Atom(\dots)}.

When converting Erlang types into JavaScript, the converted types are more expressive as they can generate themselves as tagged JavaScript objects. They are mapped as follows:

\begin{itemize}
	\item Atom $\Rightarrow$ String
	\item BitString $\Rightarrow$ Uint8Array
	\item List $\Rightarrow$ String or Array, depending the values within the List
	\item Map $\Rightarrow$ An Object in the form of \textit{\{ keys: [...], values: [...] \}}
	\item Int/Float $\Rightarrow$ Number
	\item Pid $\Rightarrow$ Not converted. Exposed as raw Erlang datatype.
	\item Process $\Rightarrow$ Not converted. Exposed as raw Erlang datatype.
	\item Tuple $\Rightarrow$ Array
\end{itemize}

The main downside to this automatic type conversion system is when dealing with anonymous functions on both the JavaScript side and the Erlang side. Since we're using JavaScript functions as the datatype representing Erlang functions, we can pass them around and invoke them as normal first class objects but the issue is that it is impossible for the arguments going into these functions and coming out of these functions to be automatically converted. This is an area of active research and thus I don't believe we'll find an adequate solution in the near future.

Lastly, since Erlang function calls in the form \textit{module:function(\dots)} are simply compiled to \textit{module.function(\dots)}, Erlang code can call native browser APIs, as well as user defined functions by simply making a call to that code. Calling \textit{window:function(\dots)} allows access to any globally accessible functions, though for ease of use, the Jarlang runtime will eventually include its own wrapper around much of the standard JavaScript APIs allowing even better interoperability.

\subsubsection{Sequential Programming (or lack thereof)}
As stated in the section above, the Jarlang runtime environment is the only environment in which compiled Erlang code is run. Because of this, we have a clear entrypoint and exitpoint \textit{(Erlang $\rightarrow$ JavaScript function calls notwithstanding)} where we can perform some logic to improve the interoperability between the Jarlang runtime environment and the external JavaScript environment.

Another thing we do in this layer is instantiate new Processes for any function calls the user makes. Whenever the user calls Erlang functions compiled through the Jarlang compiler, the runtime system intercepts these function calls and insteads wraps those function calls inside the \textit{Process.behaviour} property of a new Process whose PID gets returned.

Because Processes are run asynchronously, interleaved among other units of work during the JavaScript event loop, this neccessitates that the returned PIDs --- essentially the return value of any user-run Erlang code --- share a similar interface and design to native \textit{JavaScript Promises} such that they embody the idea of \textit{"work that needs to be done"} or \textit{"a promise of a return value in the future"}.

This means that any time you need to interface with Erlang code in JavaScript, you need to structure your code to listen for return events in the future, or in short, Erlang code compiled by the Jarlang compiler cannot be run synchronously by a user.

Moreover, multiple processes spawned sequentially side by side don't guarentee any order of execution and thus one cannot rely on this mechanism to ensure sequential code.

This was a design decision we made relatively late on since originally the Jarlang compiler and Jarlang runtime environment produced only seqential Erlang code. The tradeoff for allowing sequential Erlang code to be generated was that, at that point in time, the Jarlang compiler and runtime environment did not support the compilation or running of Erlang processes.

Because all code, even completely sequential Erlang, is executed in an asynchronous manner --- even typing commands in the Erlang shell execute in a Process as evidenced by the result of running the command \textit{self()} --- we wanted to mimic this despite the slight inconvinience of forcing such a paradigm shift on any potential users.

In line with our attempt to mimic Erlang's concurrency model however, we do make the guarentee that any \textit{sequential-only Erlang code} executed within any process is entirely sequential. We go into this in detail in the following section where we discuss how our Processes actually work and how this enables us to utilise concurrent programming paradigms in JavaScript. 

\subsubsection{Concurrent Programming} \label{sssec:num2}
As we have detailed above, all user calls into compiled Erlang code runs in the context of a Process executing a \textit{behaviour}. Processes are architected such that they resemble \textit{JavaScript Promises} for easier interoperability but also act like traditional actor model agents.

On a high level, the BEAM virtual machine (responsible for running Erlang code) schedules processes based on how long processes have been running. It has the ability to pause and resume processes when and if it sees fit. 

While it is not impossible for us to do this in JavaScript with the use timing functions sprinkled throughout compiled Erlang code to help the runtime environment schedule process behaviours, it would definitely impact the runtime of such code and the human-readability which whilst is not of paramount importance, definitely helps with the development of Jarlang.

Instead, we opted for an extremely high level simulation of how the actor model is implemented in Erlang. Erlang code is essentially strictly sequential in all but one case --- if a function contains a \textit{receive block}, the function essentially defers execution of the containing process until the \textit{receive block} has passed. This is also where our guarentee of sequential order comes from as long as the compiled code was purely sequential Erlang.

The behaviour property of a given process is a reference to the function that process should perform in the next tick of work allocated to said process. 

Processes also have an internal API which allows them to set the behaviour property to either the currently executing behaviour (repeating the current unit of work again in the next tick) or another function (execute a new behaviour in the next tick) With this simple API, we are able to implement basic actor-model concurrency.

For this to work, all processes also contain a inbox for messages to accumulate in. During \textit{receive blocks}, we pattern match against these messages in order to determine what we will execute in the next tick. As far as concurrency is concerned, this is the only place in Erlang where concurrency can occur, and as such, our implementation of actor-style concurrency is compatible with basic Erlang examples.

One of the places where our implementation makes a notable difference to Erlang's implementation is when a given process never ends from a sequential standpoint. All sequential Erlang code is run sequentially and atomically and thus, an infinite loop would lock up the browser's JavaScript thread indefinitely. In Erlang, this is not the case as the BEAM virtual machine is still free to switch to another process and execute it as it pleases.

As a more detailed example then, of how we are implementing concurrency as far as the Jarlang compiler \& runtime environment is concerned: 

\begin{enumerate}
	\item Compile normal sequential Erlang code into normal sequential JavaScript. If we reach a receieve block, split the function into three pieces such that we have a PRE-RECIEVE function, a POST-RECIEVE function and finally the receieve block itself.
	\item Assemble these function segments as inline anonymous function calls, passing variables from one segment of the function to another by use of a closure --- this allows us to bind variables from one function into another quite naturally.
	\item Modify the recieve blocks such that if no messages are matched, set the process behaviour to the same recieve block allowing us to indefinitely defer processes until a message is matched.
	\item When a function containing non-sequential Erlang is run, the process runs sequentially until the receive block is met (the PRE-RECEIVE block). Once the receive block is met, the process defers itself indefinitely such that the only thing it does each tick of worktime it gets given is check its message inbox.
	\item When a message is matched, it sequentially runs the code coupled with the matched case before deferring again, but this time to the POST-RECIEVE function.
\end{enumerate}

Via this process, messages can trigger deferred processes awaiting messages to continue execution, and can themselves await messages. With this basic behaviour we can implement basic OTP-like server functionality as well as state-machine like functionality.

One of the things yet to be implement is a mechanism to cancel a receive block after a period of time. This can be implemented via simply counting the time which has passed in between process ticks and exiting the receive block after so long but this has not been implemented at the time of writing.

It is also important to note that while for simple cases of concurrent behaviour we successfully mimic Erlang code, for more complex patterns containing nested receive blocks, the Jarlang compiler currently does not produce the correct output as we cannot so naively simply split a function into segments. We do plan on leveraging JavaScript's async/await concurrency constructs which will be able to help us mimic this behaviour better in the future.

\subsubsection{Distributed Programming}

Another important facet of Erlang's concurrency model is that it is fairly trivial to expand across multiple different nodes to allow easy distributed programming.

Whilst at this point in time Jarlang doesn't provide any official mechanism to allow for such distributed programming --- and likely never will, due to the following explanation --- it would be trivial to implement a similar system in JavaScript to facilitate distributed programming. 

Because the only facility processes have to trigger asynchronous behaviours is via message passing, and all messages are sent to either known PIDs in the global PID table or known Atoms in the global Atom table, one could easily implement a channel which listens for messages sent to \textit{virtual PIDs/Atoms} belonging to distributed processes. This channel could then simply forward the message via any web mechanism capable of real time communication such as \textit{WebRTC} or more commonly \textit{WebSockets}. 

Following this, a layer would need to be implement to route received distributed messages to their intended target but once this was done, any given process would be able to trivially and arbitrarily send and receive messages from distributed nodes.

The Jarlang runtime environment does however provide a mechanism to customise the PIDs which otherwise get automatically generated in order to facilitate users to be able to tag PIDs as distributed or local. Even without this however, distribution of nodes is simple and nothing is neccessarily even stopping Jarlang process nodes from sending and/or receiving messages from real Erlang process nodes on the backend, assuming the correct layers to translate from Erlang to JavaScript and vice versa are implemented.

\subsubsection{Current Runtime Limitations}

While as a whole, the Jarlang runtime environment works quite successfully in emulating the behaviour of running Erlang code at a high level, there are some drawbacks and limitations to what can be done with Jarlang at this point in time. While some of these can be handled by small or large changes, some are limitations on our architectural approach and likely won't be resolved in the near future if at all.

They are listed as follows.

\begin{itemize}
	\item Currently we provide no mechanism for processes to supervise or react to events of linked processes.
	\item Currently, scope details can be lost if receive blocks are heavily nested
	\item Automatic type coercion between the JavaScript environment and Jarlang runtime environment is a leaky abstraction which can't be applied to functions. We can maybe fix this by implementing all Erlang functions as wrappers around lambda instead of generating functions directly, but the output of these wrapped lambas still couldn't neccessarily be converted easily or usefully.
	\item The \textit{spawn/N} functions cannot currently spawn functions without relying on JavaScripts \textit{eval} function. This is because we cannot access programmatically the contents of compiled Erlang modules as they are declared as a \textit{const variable} and thus do not bind to the global scope. We chose not to simply use a \textit{var variable} instead but to have Erlang modules register themselves with the runtime environment upon initialisation. This is currently a pending task.
	\item We currently do not and cannot garbage collect proceses. Upon ending execution they defer forever since we can never be sure there are no references to these processes either inside the runtime environment (which is implementable) or outside in the open JavaScript environment (which isn't implementable).
\end{itemize}

\subsection{The Jarlang Compiler}
We utilise the Erlang compiler to help us leverage some priliminary optimisations performed, and also to allow us to work in a much smaller language representation allowing us to ignore much syntactic sugar which exists in standard Erlang --- this smaller language is Erlang's intermediate representation called \textit{Core Erlang}.

One huge gain from utilising Core Erlang instead of standard Erlang is the ability to easily parse it and get an Abstract Syntax Tree out of it using standard Erlang tools. This allows us to not have to implement a parser or a lexer for our compiler (though as stated, if we ever want to bootstrap the Jarlang compiler, we will likely need to change how this is handled).

Since the Erlang compiler also has to get to the stage where it is generated code output, we also know that any programs passed into the Jarlang compiler are valid Erlang programs. 

We will go into more details about steps the Jarlang compiler takes to generated valid JavaScript output, as well as outline tools used.

\subsubsection{Pre-Jarlang: The Erlang Compiler}
As briefly stated above, before the Jarlang compiler is able to do any work, the Erlang compiler has to more or less successfully compile Erlang source code files into Erlang's intermediate language --- Core Erlang --- which means we don't have to worry about certain classes of errors such as referencing undefined variables or throwing errors for invalid conditional logic or pattern match logic.

For example the Erlang function shown in Figure \ref{fig:code_comparison:erl} will throw an error if the input is anything other than the atom 'apple'. In this example there is no code that states what should occur in the event that the input is not the atom 'apple' and as such the compiler generates a second clause (Figure \ref{fig:code_comparison:erl_ast}) to match any value and throw an appropriate error. This conveniently allows us to reproduce the required functionality by parsing the compiler generated function as normal (Figure \ref{fig:code_comparison:js}), rather than concerning ourselves with this specific case.
%\begin{figure}[htb]
%\centering
% \begin{figure}[t]
% 	\centering
% 		\begin{verbatim}
% 		...
% 		error_if_not_apple(apple)->
% 		  ok.
% 		\end{verbatim}
% 	\caption{Erlang source}
% 	\label{fig:code_comparison:erl}
% \end{figure}
% \begin{figure}[t]
% 	\centering
% 	\begin{verbatim}
% 	...
% 	[{{c_var,[],{error_if_not_apple,1}},
% 	  {c_fun,[],
% 	    [{c_var,[],'_cor0'}],
% 	    {c_case,[],
% 	      {c_var,[],'_cor0'},
% 	      [{c_clause,[],
% 	         [{c_literal,[],apple}],
% 	         {c_literal,[],true},
% 	         {c_literal,[],ok}},
% 	       {c_clause,
% 	         [compiler_generated],
% 	         [{c_var,[],'_cor1'}],
% 	         {c_literal,[],true},
% 	         {c_primop,
% 	           [{function_name,{error_if_not_apple,1}}],
% 	           {c_literal,[],match_fail},
% 	           [{c_tuple,[],
% 	             [{c_literal,[],function_clause},
% 	                {c_var,[],'_cor1'}]}]}}]}}},
% 	...
% 	\end{verbatim}
% 	\caption{Core Erlang AST of Figure \ref{fig:code_comparison:erl}}
% 	\label{fig:code_comparison:erl_ast}
% \end{figure}
% \begin{figure}[t]
% 	\centering
% 		\begin{verbatim}
% 		...
% 		'error_if_not_apple/1': function (_cor0) {
% 		  if (function () {
% 		    if (_cor0.match(new Atom('apple'))) {
% 		      return new Atom('true');
% 		    }
% 		  }.bind(this)()) {
% 		    return new Atom('ok');
% 		  } else if (function () {
% 		    return new Atom('true');
% 		  }()) {
% 		    let _cor1 = _cor0;
% 		    throw '** match_fail: TODO Errors dont parse nicely\\n' + 'Message';
% 		  }
% 		},
% 		...
% 		\end{verbatim}
% 	\caption{Jarlang transpiled equivalent of Figure \ref{fig:code_comparison:erl}}
% 	\label{fig:code_comparison:js}
% \end{figure}
%\caption{Very code. Much geek. Wow!}
%\caption{Comparison of Erlang source code and Jarlang transpiled equivalent.}
%\label{fig:code_comparison}
%\end{figure}


\subsubsection{Pattern Matching, Conditional Logic \& Message Receiving}
\subsubsection{Variable Declaration \& Assignment in Matching}
\subsubsection{Erlang Module implementation} \label{sssec:num1}
\subsection{ErlPKG}

\section{Conclusions}
\label{Conclusions}

[section not done yet]

\section{Acknowledgement}
The authors wish to thank and/or acknowledge the following:
\begin{enumerate}
	\item Scott Owens - For supervising our project, and being generally available whenever we needed help or assistance, and talked us through just about all of our technical decisions.
	\item Simon Thompson - For convincing us that rolling our own type checking system was not a good idea (and introducing to us the amazing \textit{Erlang Dialyzer}), and talking with us about the feasibility in our concurrency approach.
	\item Gordon Guthrie - For his similar project --- \textit{LuvvieScript (URL now defunct)} --- and though no useful source-code was shared, his talk about how he tackled hooking into the Erlang compiler and tools he used (\textit{such as ESPrima and ESCodegen}) provided a brilliant starting point for \textit{Jarlang}.
\end{enumerate}
\appendix
\section*{Appendix A. TODO: Do we need an appendix?}


[section ommitted]



\vskip 0.2in
\todo{Bibliography is still the template version, will need replacing.}
\bibliography{jarlang_technical_report}
\bibliographystyle{kentHarvard}

\end{document}
