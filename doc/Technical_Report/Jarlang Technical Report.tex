\documentclass[twoside,12pt,titlepage,a4paper]{article}
\usepackage{url}
% kentHarvard requires natbib
\usepackage{natbib}
% add line numbers
\usepackage{lineno}
%\linenumbers %Comment this out to remove line numbers

\usepackage[pass]{geometry}
\usepackage{graphicx}
\renewcommand{\baselinestretch}{1.3}
\usepackage{todonotes}
%\usepackage{minted}
\usepackage{subcaption}

\title{CO600 Project: Jarlang\\ Technical Report}
\author{
	\begin{tabular}{ c c c }
		Chris Bailey & Andrew Johnson & Nick Laine \\ 
		\url{cb661@kent.ac.uk} & \url{apj8@kent.ac.uk} & \url{nl227@kent.ac.uk}  
	\end{tabular}\\
	\\ \vspace{10mm}
   \includegraphics[scale=0.6]{Kent_Comp_294_RGB} \\
   School of Computing \\
   University of Kent \\
   United Kingdom \\ \vspace{10mm} \\ Word Count: 6,100}
\begin{document}

\newgeometry{hmarginratio=1:1}    %% make layout symmetric
\maketitle
\restoregeometry              %% restore the layout

\begin{abstract}
	This paper describes the development and operation of an Erlang to JavaScript compiler henceforth referred to as \textit{Jarlang}. 
	
	The primary aim of \textit{Jarlang} is to generate valid JavaScript from any error-free Erlang module source code. The result of this JavaScript generation should be easily included on a given web-page and be easily integrated into existing front-end codebase. 
	
	Secondary aims for \textit{Jarlang} include the ability to leverage Erlang-style concurrency in what is more often than not a strictly single-threaded environment, as well as being able to \textit{execute correctly} the generated JavaScript --- this presumes the re-implementation of the Erlang standard library and Erlang runtime environment as the equivalent \textit{Jarlang runtime environment}.
	
	While fully implementing the \textit{Jarlang runtime environment} is not the primary goal of this project, enough of the \textit{Jarlang runtime environment} will have been implemented so that we can successfully emulate things such as Erlang's datatypes, message passing and concurrency model --- otherwise, enough that basic test-compilations can be successfully run \textit{(common tests such as 'hello, world!', 'fibbonaci' and 'factorial')}.
\end{abstract}

\section{Introduction}
\label{Introduction}
	\textit{Jarlang} is a compiler implemented in Erlang (\textit{and JavaScript}) whose goal is to be able to compile valid Erlang module source code into valid JavaScript source code.

	\textit{Jarlang} thus provides several benefits to potential users such as the ability to execute, or demonstrate, Erlang code on the web which could help the official Erlang documentation but also provides educational benefits. \textit{Jarlang} also allows developers to unify their tech-stack which is a popular trend amongst contemporary web developers. Unifying tech-stacks results in less time spent context switching when switching from front-end programming and back-end programming, as well as making both front-end and back-end programming accessible to any competant Erlang developer.
	
	Most of our codebase is written in Erlang, which is the same language as our compilation source. The main motivation behind this is to eventually bootstrap the \textit{Jarlang compiler} (compiling the compiler). If we were to compile \textit{Jarlang}'s source code into JavaScript, we essentially have an Erlang compiler which can run on its own on the web, only furthering educational benefit as Erlang programmers therefore don't need to install an Erlang compiler themselves. This would also allow Erlang to act moreso as a first class citizen on the Web.
	
	Due to time constraints however, the currently implementation of the \textit{Jarlang compiler} hooks into the existing Erlang compiler and thus has a hard dependency on it. We utilise the Erlang compiler to parse, lex, validate, and optimise Erlang source code. After these steps, the Erlang compiler allows us to manipulate its intermediate language known as \textit{Core Erlang}, which is where the \textit{Jarlang compiler} performs most of its work.
	
	In order to remove our dependency on the Erlang compiler, we will need to write a parser, lexer and validater for Erlang, as well as generate a \textit{Core Erlang} compatible abstract syntax tree for us to work on, which whilst is not impossible, is definitely beyond the scope and time constraints of this project.

	We also intended to, and in many ways, have succeeded in implementing much of Erlang's functionality --- The results of the \textit{Jarlang compiler} successfully emulate Erlang style modules (including private and exported functions), Erlang style variadic functions and function overloading, and more abmitiously, implementing a concurrent actor-model system leveraging JavaScript's event loop.
\section{Background}
\label{Background}


\section{Aims}
\label{Aims}


\section{Project Results}
\label{Results}

\todo{Excerpt from guideline doc:	(Several technical content sections)
	This is where you go into detail about what you have done. You will need to decide the titles for these sections yourself; they will depend on the content of the project. These sections should summarise the technical and scientific achievements of the project.
	
	Depending on the nature of your project, these sections may include: a comparison of different approaches that you considered, accounts of experimental work, mathematical analyses, specifications, top-level architectural diagrams, results obtained, problems encountered, workarounds, user evaluations, performance measures, testing regimes and results, comparisons between different approaches adopted, comparisons with existing work on similar problems.
	
	In particular, you should give a mixture of general discussion of your work and particular examples. Too much general discussion and the reader cannot easily get a handle on what you are doing; too many specific examples and the document fails to "tell a story".
}

\todo{This text is a copy of the abstract assessment text, it will need re-writing.}
The Jarlang transpiler is capable of successfully transpiling relatively simple Erlang source code to JavaScript. One of the main issues Jarlang has is the lack of a standard library, thus more complex code may not run after being transpiled. In time, this issue will be resolved by simply implementing the necessary Erlang language features (of particular importance, Erlang’s data types) in JavaScript, so that we can transpile more of Erlang’s standard library to utilise in transpiled code. We have succeeded in implementing the majority of Erlang’s data types, however they have yet to be integrated into the transpiled code.

In addition to this, we have implemented actor-style concurrency in JavaScript. Our success in implementing this has eliminated many of the initial concerns we harboured for this project, however this has raised other concerns such as garbage collection of completed processes. We have decided that this is outside the scope of this project.

\subsection{Jarlang Run-Time System}
\subsection{Erlang Datatypes}
\subsection{AST Conversion}
	By using the Erlang compiler to produce Core Erlang and it's AST representation we have secured several benefits, some minor conveniences and some critical to achieving a viable program in the time available to us.
\subsubsection{Compiler Generated Code}
	In Erlang conditional logic \& function pattern matching, unless explicitly defined in the source code, an error is thrown when the supplied value or parameters do not match any of the required patterns. fortunately we have not been required to create this functionality directly, rather, during compilation to Core Erlang the Erlang compiler adds a catch-all clause to the associated code that will explicitly call the built-in-function that emits errors.
	
	For example
	\begin{figure}[htb]
		\centering
		\begin{subfigure}[t]{.5\linewidth}
			\centering         
				\begin{verbatim}
				...
				error_if_not_apple(apple)->
				ok.
				\end{verbatim}
			\caption{Erlang source}
		\end{subfigure}%
		\begin{subfigure}[t]{.5\linewidth}
			\centering
				\begin{verbatim}
				...
				'error_if_not_apple/1': function (_cor0) {
				if (function () {
				if (_cor0.match(new Atom('apple'))) {
				return new Atom('true');
				}
				}.bind(this)()) {
				return new Atom('ok');
				} else if (function () {
				return new Atom('true');
				}()) {
				let _cor1 = _cor0;
				throw '** match_fail: TODO Errors dont parse nicely\\n' + 'Message';
				}
				},
				...
				\end{verbatim}
			\caption{Jarlang transpiled equivalent}
		\end{subfigure}
		%\caption{Very code. Much geek. Wow!}
		\caption{Comparison of Erlang source code and Jarlang transpiled equivalent.}
	\end{figure}
	
	
\subsubsection{Pattern Matching, Conditional Logic \& Message Receiving}
\subsubsection{Variable Declaration \& Assignment in Matching}
\subsection{ErlPKG}

\section{Conclusions}
\label{Conclusions}

 [section not done yet]

\section{Acknowledgement}
	The authors wish to thank and/or acknowledge the following:
	\begin{enumerate}
		\item Scott Owens - For supervising our project, and being generally available whenever we needed help or assistance, and talked us through just about all of our technical decisions.
		\item Simon Thompson - For convincing us that rolling our own type checking system was not a good idea (and introducing to us the amazing \textit{Erlang Dialyzer}), and talking with us about the feasibility in our concurrency approach.
		\item Gordon Guthrie - For having tackled a similar project --- \textit{LuvvieScript (URL now defunct)} --- and though no useful source-code was shared, his talk about how he tackled hooking into the Erlang compiler and tools he used (\textit{such as ESPrima and ESCodegen}) provided a brilliant starting point for \textit{Jarlang}.
	\end{enumerate}
\appendix
\section*{Appendix A. TODO: Do we need an appendix?}


[section ommitted]



\vskip 0.2in
\todo{Bibliography is still the template version, will need replacing.}
\bibliography{jarlang_technical_report}
\bibliographystyle{kentHarvard}

\end{document}
